## SGL (Small Graphics Library)

### 移植步骤如下：
1. 复制`source`目录下的所有文件到自己的项目中
2. 将`include`目录添加到头文件路径中
3. 仅保留`mm`目录下的`lwmem`目录，其他目录删除掉
4. 将`source`目录添加到头文件路径中
5. 修改`sgl_config.h`文件的内容，以适配自己的硬件，修改如下(仅供参考):
    ```c
    #define  CONFIG_SGL_PANEL_PIXEL_DEPTH                      16
    #define  CONFIG_SGL_EVENT_QUEUE_SIZE                       16
    #define  CONFIG_SGL_SYSTICK_MS                             10
    #define  CONFIG_SGL_DIRTY_AREA_THRESHOLD                   64
    #define  CONFIG_SGL_COLOR16_SWAP                           0   
    #define  CONFIG_SGL_ANIMATION                              0
    #define  CONFIG_SGL_DEBUG                                  0
    #define  CONFIG_SGL_LOG_COLOR                              1
    #define  CONFIG_SGL_LOG_LEVEL                              0
    #define  CONFIG_SGL_TEXT_UTF8                              0
    #define  CONFIG_SGL_OBJ_USE_NAME                           0
    #define  CONFIG_SGL_USE_STYLE_UNIFIED_API                  1
    #define  CONFIG_SGL_BOOT_LOGO                              0
    #define  CONFIG_SGL_BOOT_ANIMATION                         0
    #define  CONFIG_SGL_HEAP_ALGO                              lwmem
    #define  CONFIG_SGL_FL_INDEX_MAX                           20
    #define  CONFIG_SGL_HEAP_MEMORY_SIZE                       10240
    #define  CONFIG_SGL_FONT_SONG23                            1
    #define  CONFIG_SGL_FONT_CONSOLAS23                        0
    #define  CONFIG_SGL_FONT_KAI33                             0
    #define  CONFIG_SGL_FONT_CONSOLAS14                        0
    ```
    上面的参数的含义如下：
    - `CONFIG_SGL_PANEL_PIXEL_DEPTH`: 屏幕的像素深度，16位
    - `CONFIG_SGL_EVENT_QUEUE_SIZE`: 事件队列大小，这里设置为16
    - `CONFIG_SGL_SYSTICK_MS`: 系统滴答时钟，这里设置为10ms
    - `CONFIG_SGL_COLOR16_SWAP`: 颜色16位字节对调，这里设置为0
    - `CONFIG_SGL_DEBUG`: 调试开关，打开
    - `CONFIG_SGL_LOG_COLOR`: 日志颜色开关，打开
    - `CONFIG_SGL_LOG_LEVEL`: 日志等级，设置为0
    - `CONFIG_SGL_TEXT_UTF8`: 是否使用UTF-8编码，这里设置为0
    - `CONFIG_SGL_USE_STYLE_UNIFIED_API`: 控件样式统一接口开关，打开
    - `CONFIG_SGL_HEAP_ALGO`: 内存分配算法，设置为`lwmem`
    - `CONFIG_SGL_FL_INDEX_MAX`: tlsf字体索引最大值，因为使用了`lwmem`，所以这里设置为0
    - `CONFIG_SGL_HEAP_MEMORY_SIZE`： 内存分配算法的堆大小，单位：字节，这里设置为10K
    - `CONFIG_SGL_FONT_SONG23`: 宋体23号字体开关，打开
    - `CONFIG_SGL_FONT_CONSOLAS23`: 思源黑体23号字体开关，关闭
    - `CONFIG_SGL_FONT_KAI33`: 楷体33号字体开关，关闭
    - `CONFIG_SGL_THEME_DEFAULT`: 默认主题开关，打开

然后编译整个项目，看看能否编译通过，如果一切顺利的话，继续下面步骤。

### 注册底层绘图接口（必须）
和大多数GUI库一样，在使用SGL库之前，请注册底层的绘图接口，底层接口的注册如下：
```c

void panel_flush_area(int16_t x, int16_t y, int16_t w, int16_t h, sgl_color_t *src)
{
    tft_set_win(x, y, x + w - 1, y + h - 1);
	GPIO_WriteBit(SPI_DC_PORT, SPI_DC_PIN, 1);
	SPI1_WriteMultByte((uint8_t*)src, w * h * 2);
}

...
sgl_device_fb_t fb_dev = {
    .xres = CONFIG_SGL_PANEL_WIDTH,
    .yres = CONFIG_SGL_PANEL_HEIGHT,
    .xres_virtual = CONFIG_SGL_PANEL_WIDTH,
    .yres_virtual = CONFIG_SGL_PANEL_HEIGHT,
    .flush_area = panel_flush_area,
    .buffer[0] = panel_buffer,
    .buffer_size = SGL_ARRAY_SIZE(panel_buffer), 
};

sgl_device_fb_register(&fb_dev);
...
```
上面的过程中定义了一个`sgl_device_fb_t`结构体，并且初始化了一些主要的参数，参数的含义如下：
- `xres`: 屏幕的宽度
- `yres`: 屏幕的高度
- `xres_virtual`: 屏幕的虚拟宽度
- `yres_virtual`: 屏幕的虚拟高度
- `flush_area`：刷新区域函数，用于刷新指定区域
- `buffer[0]`：帧缓冲区指针，指向帧缓冲区地址处，如何需要双帧缓冲区，则需要设置`buffer[1]`
- `buffer_size`：帧缓冲区大小，单位：字节

`sgl_device_fb_register`函数用于注册帧缓冲区设备，参数为`sgl_device_fb_t`结构体指针。

### 注册调试接口（可选）
使用`void sgl_device_log_register(void (*log_puts)(const char *str))`函数来注册调试接口， 参数为一个指向`log_puts`函数的指针，例如下面的代码：
```c
void uart_put_string(const char *str) {
   /* 发送串口数据 */
}

...
sgl_device_log_register(uart_put_string);
...

```

### 调用sgl_init()函数
首先需要先包含`sgl.h`头文件，然后调用`sgl_init()`函数用于初始化`SGL`库，其中包括内存初始化，`SGL`数据结构初始化等，然后即可开始创建控件和绘制图形了，例如下面的代码：
```c
#include <sgl.h>

/* 系统时钟中断服务函数，设置为1ms中断一次 */
void systick_handler(void)
{
    sgl_tick_inc(1);
}


int main(void)
{
    sgl_device_log_register(uart_put_string);
    sgl_device_fb_register(&fb_dev);

    sgl_init();

    /* 创建控件 */

    while(1) {
        sgl_task_handle();
    };

    return 0;
}
```

### 注册鼠标事件(或者触摸点击事件)
在鼠标点击事件或者触摸点击事件的中断服务函数中调用`sgl_event_send_pos()`函数，这个函数会处理鼠标点击事件或者触摸点击事件，参数为鼠标点击事件坐标和触摸点击事件的类型，例如下面的代码：
```c
/* 包含头文件 */
#include <sgl.h>
...
static void mouse_event_interrupt(xxxxx) 
{
    sgl_event_pos_t pos;

    if(判断按下) {
        pos.x = event->motion.x;
        pos.y = event->motion.y;
        sgl_event_send_pos(pos, SGL_EVENT_PRESSED);
    }
    else if(判断释放) {
        pos.x = event->motion.x;
        pos.y = event->motion.y;
        sgl_event_send_pos(pos, SGL_EVENT_RELEASED);
    }
    else if(判断移动) {
        pos.x = event->motion.x;
        pos.y = event->motion.y;
        sgl_event_send_pos(pos, SGL_EVENT_MOTION);
    }
}
```


### 创建控件
如用如下代码来创建一个控件：
```c
sgl_obj_t *button = sgl_button_create(NULL);
sgl_obj_set_pos(button, 100, 300);
sgl_obj_set_size(button, 200, 100);
sgl_obj_set_font(button, &song23);
sgl_obj_set_radius(button, 60);
sgl_obj_set_border_width(button, 0);
sgl_obj_set_style(button, SGL_STYLE_TEXT_COLOR, 0x5de);
sgl_obj_set_style(button, SGL_STYLE_TEXT ,SGL_TEXT("Click me!"));
```

## DMA支持
`SGL`库支持`DMA`，即使用`DMA`来传输数据，这样能提高效率，但是`DMA`支持需要硬件支持，如果想使用`DMA`，请使用双帧缓冲，只需要设置`buffer[1]`即可:
底层刷图接口：  
```c
/* 系统时钟中断服务函数，设置为1ms中断一次 */
void systick_handler(void)
{
    sgl_tick_inc(1);
}

...
void panel_flush_area(int16_t x, int16_t y, int16_t w, int16_t h, sgl_color_t *src)
{
    while (DMA is busy) {
        等待DMA完成
    }
    tft_set_win(x, y, x + w - 1, y + h - 1);
	GPIO_WriteBit(SPI_DC_PORT, SPI_DC_PIN, 1);
	SPI1_DMA_WriteMultByte((uint8_t*)src, w * h * 2);
}

sgl_color_t panel_buffer0[PANEL_WIDTH * 10];
sgl_color_t panel_buffer1[PANEL_WIDTH * 10];

...
int main(void)
{
    ...
    sgl_device_fb_t fb_dev = {
        .xres = CONFIG_SGL_PANEL_WIDTH,
        .yres = CONFIG_SGL_PANEL_HEIGHT,
        .xres_virtual = CONFIG_SGL_PANEL_WIDTH,
        .yres_virtual = CONFIG_SGL_PANEL_HEIGHT,
        .flush_area = panel_flush_area,
        .buffer[0] = panel_buffer0,
        .buffer[1] = panel_buffer1,
        .framebuffer_size = SGL_ARRAY_SIZE(panel_buffer), 
    };

    sgl_device_fb_register(&fb_dev);
    ...
    sgl_init();

    /* 创建控件 */

    while(1) {
        sgl_task_handle();
    };

    return 0;
}

```
